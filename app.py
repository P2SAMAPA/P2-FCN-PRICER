import streamlit as st; import numpy as np; import pandas as pd; import yfinance as yf; from scipy.optimize import brentq def run_sim(c, p, r, t, s, k, f, n): steps = p.shape[0]; n_s = p.shape[1]; wo = np.min(p, axis=2); obs = np.arange(int((f/12)*252), steps, int((f/12)252)); pay = np.zeros(n_s); act = np.ones(n_s, dtype=bool); acc = np.zeros(n_s); c_val = (c(f/12))*100 for i, step in enumerate(obs): acc[act] += c_val if step >= int((n/12)*252): idx = act & (wo[step] >= k); pay[idx] = 100 + acc[idx]; act[idx] = False if np.any(act): pay[act] = np.where(wo[-1, act] >= s, 100, wo[-1, act]) + acc[act] return np.mean(pay) * np.exp(-r * t) st.title("ðŸš€ FCN Pricing Terminal") t_in = st.text_input("Assets", "AMZN, ALB") if st.button("RUN"): v = np.array([0.35, 0.48]); r = 0.045; dt = 1/252; n_s = 10000; n_d = 252 drift = (r - 0.5 * (v**2)) * dt; shock = v * np.sqrt(dt); rets = np.random.normal(drift, shock, (n_d, n_s, 2)); paths = 100 * np.exp(np.cumsum(rets, axis=0)) try: f = lambda x : run_sim(x, paths, r, 1.0, 75, 100, 1, 3) - 100; sol = brentq(f, 0, 1.0) st.metric("ANNUAL YIELD", f"{sol * 100:.2f}%") st.write("Calculated using Geometric Brownian Motion.") except Exception as e: st.error(f"Error: {e}")
